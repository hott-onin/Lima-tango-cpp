static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         Ufxc.cpp
//
// description :  C++ source for the Ufxc and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Ufxc are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name    |  Method name
//	----------------------------------------
//  State           |  dev_state()
//  Status          |  dev_status()
//  LoadConfigFile  |  load_config_file()
//
//===================================================================


#include <tango.h>
#include <PogoHelper.h>
#include <Ufxc.h>
#include <UfxcClass.h>

namespace Ufxc_ns
{
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::Ufxc(string &s)
// 
// description : 	constructor for simulated Ufxc
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
Ufxc::Ufxc(Tango::DeviceClass *cl, string &s)
:Tango::Device_4Impl(cl, s.c_str())
{
	init_device();
}
Ufxc::Ufxc(Tango::DeviceClass *cl, const char *s)
:Tango::Device_4Impl(cl, s)
{
	init_device();
}
Ufxc::Ufxc(Tango::DeviceClass *cl, const char *s, const char *d)
:Tango::Device_4Impl(cl, s, d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Ufxc::delete_device()
{
	DELETE_DEVSTRING_ATTRIBUTE(attr_libVersion_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_firmwareVersion_read);
	DELETE_SCALAR_ATTRIBUTE(attr_triggerAcquisitionFrequency_read);
	DELETE_SCALAR_ATTRIBUTE(attr_detectorTemperature_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdLow_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdHigh_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdLow1_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdHigh1_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdLow2_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdHigh2_read);
	DELETE_SCALAR_ATTRIBUTE(attr_geometricalCorrection_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_currentAlias_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_currentConfigFile_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_countingMode_read);
    
	//	Delete device allocated objects

	INFO_STREAM << "Remove the inner-appender." << endl;
    yat4tango::InnerAppender::release(this);

	//!!!! ONLY LimaDetector device can do this !!!!
	//if(m_ct!=0)
	//{
	//    ControlFactory::instance().reset("Ufxc");
	//    m_ct = 0;
	//}    

	// Exit acquisition task
	INFO_STREAM << "Exit yat::DeviceTask." << endl;
	m_my_task.reset();

	m_map_alias_config_files.clear();
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Ufxc::init_device()
{
	INFO_STREAM << "Ufxc::Ufxc() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();

	CREATE_DEVSTRING_ATTRIBUTE(attr_libVersion_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_firmwareVersion_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_SCALAR_ATTRIBUTE(attr_triggerAcquisitionFrequency_read);
	CREATE_SCALAR_ATTRIBUTE(attr_detectorTemperature_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdLow_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdHigh_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdLow1_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdHigh1_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdLow2_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdHigh2_read);
	CREATE_SCALAR_ATTRIBUTE(attr_geometricalCorrection_read);
	CREATE_DEVSTRING_ATTRIBUTE(attr_currentAlias_read, 255);
	CREATE_DEVSTRING_ATTRIBUTE(attr_currentConfigFile_read, 255);
	CREATE_DEVSTRING_ATTRIBUTE(attr_countingMode_read, 255);

	m_is_device_initialized = false;
	set_state(Tango::INIT);
	m_status_message.str("");
	strcpy(*attr_currentAlias_read     , "Unknown");
	strcpy(*attr_currentConfigFile_read, "Unknown");
	strcpy(*attr_countingMode_read     , "Unknown");

	INFO_STREAM << "Create the inner-appender in order to manage logs." << endl;  
    yat4tango::InnerAppender::initialize(this, 512);

	try
	{
		//- get the main object used to pilot the lima framework
		//in fact LimaDetector is create the singleton control objet
		//so this call, will only return existing object, no need to give it the ip !!
		m_ct = ControlFactory::instance().get_control("Ufxc");

		//- get interface to specific camera
		m_hw = dynamic_cast<lima::Ufxc::Interface*> (m_ct->hwInterface());

		//- get camera to specific detector
		m_camera = &(m_hw->getCamera());
	}
	catch(Exception& e)
	{
		INFO_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}
	catch(...)
	{
		INFO_STREAM << "Initialization Failed : UNKNOWN" << endl;
		m_status_message << "Initialization Failed : UNKNOWN" << endl;
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}

	//---------------------------------------------------------
	//- Prepare alias for each configuration file
	//---------------------------------------------------------
	INFO_STREAM << "- Prepare alias for each configuration file" << endl;
	for(size_t i = 0;i < detectorConfigFiles.size();i++)
	{
		yat::StringTokenizer config_files(detectorConfigFiles.at(i), ";");
		string alias = config_files.next_token();
		string file_name = config_files.next_token();
		std::transform(alias.begin(), alias.end(), alias.begin(), ::toupper);
		m_map_alias_config_files.insert(make_pair(alias, file_name));
		INFO_STREAM << "  [alias : " << alias << " , file : " << file_name << endl;
	}

	m_is_device_initialized = true;
	try
	{
		set_state(Tango::DISABLE);
		//- Create the task in order to load_config_file() with last memorized file
		m_my_task.reset(new MyTask(this), TaskExiter());
		m_my_task->go();

		if(autoLoad)
		{
			load_config_file(const_cast<Tango::DevString> (memorizedConfigAlias.c_str()));
		}

		//then write attributes at init with last memorized values
		INFO_STREAM << "Write tango hardware at Init - thresholdLow." << endl;
		Tango::WAttribute &thresholdLow = dev_attr->get_w_attr_by_name("thresholdLow");
		*attr_thresholdLow_read = attr_thresholdLow_write = memorizedThresholdLow;
		thresholdLow.set_write_value(*attr_thresholdLow_read);
		write_thresholdLow(thresholdLow);

		INFO_STREAM << "Write tango hardware at Init - thresholdHigh." << endl;
		Tango::WAttribute &thresholdHigh = dev_attr->get_w_attr_by_name("thresholdHigh");
		*attr_thresholdHigh_read = attr_thresholdHigh_write = memorizedThresholdHigh;
		thresholdHigh.set_write_value(*attr_thresholdHigh_read);
		write_thresholdHigh(thresholdHigh);

		INFO_STREAM << "Write tango hardware at Init - geometricalCorrection." << endl;
		Tango::WAttribute &geometricalCorrection = dev_attr->get_w_attr_by_name("geometricalCorrection");
		*attr_geometricalCorrection_read = attr_geometricalCorrection_write = memorizedGeometricalCorrection;
		geometricalCorrection.set_write_value(*attr_geometricalCorrection_read);
		write_geometricalCorrection(geometricalCorrection);

        INFO_STREAM << "Write tango hardware at Init - countingMode." << endl;
        m_is_CountingMode_init = true;
        Tango::WAttribute & countingMode = dev_attr->get_w_attr_by_name("countingMode");
        strcpy(*attr_countingMode_read, memorizedCountingMode.c_str());
        countingMode.set_write_value(*attr_countingMode_read);
        write_countingMode(countingMode);
        m_is_CountingMode_init = false;

		/////////
        lima::Ufxc::Camera::CountingModes acq_mode;
		m_camera->getCountingMode(acq_mode);
		DEBUG_STREAM << "acq_mode = " << acq_mode << endl;

		//available only in mode pump & probe (i.e Trigger Ext Multi and Bpp2)
		if(acq_mode == lima::Ufxc::Camera::CountingModes::PumpProbeProbe_32)
		{
            INFO_STREAM << "Write tango hardware at Init - triggerAcquisitionFrequency." << endl;
            update_triggerAcquisitionFrequency();

            // update the valid ranges for exposure and latency times
            m_hw->getSyncCtrl().updateValidRanges();
		}
		/////////
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		m_status_message << "Initialization Failed : ";
		for(unsigned i = 0;i < df.errors.length();i++)
		{
			m_status_message << df.errors[i].desc << endl;
		}
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}
	catch(Exception& e)
	{
		ERROR_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}


	dev_state();
}


//+----------------------------------------------------------------------------
//
// method : 		Ufxc::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Ufxc::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AutoLoad"));
	dev_prop.push_back(Tango::DbDatum("DetectorConfigFiles"));
	dev_prop.push_back(Tango::DbDatum("ConfigIpAddress"));
	dev_prop.push_back(Tango::DbDatum("ConfigPort"));
	dev_prop.push_back(Tango::DbDatum("SFP1IpAddress"));
	dev_prop.push_back(Tango::DbDatum("SFP1Port"));
	dev_prop.push_back(Tango::DbDatum("SFP2IpAddress"));
	dev_prop.push_back(Tango::DbDatum("SFP2Port"));
	dev_prop.push_back(Tango::DbDatum("SFP3IpAddress"));
	dev_prop.push_back(Tango::DbDatum("SFP3Port"));
	dev_prop.push_back(Tango::DbDatum("Timeout"));
	dev_prop.push_back(Tango::DbDatum("MemorizedThresholdLow"));
	dev_prop.push_back(Tango::DbDatum("MemorizedThresholdHigh"));
	dev_prop.push_back(Tango::DbDatum("MemorizedConfigAlias"));
	dev_prop.push_back(Tango::DbDatum("MemorizedTriggerAcquisitionFrequency"));
	dev_prop.push_back(Tango::DbDatum("MemorizedGeometricalCorrection"));
	dev_prop.push_back(Tango::DbDatum("MemorizedCountingMode"));
	dev_prop.push_back(Tango::DbDatum("SFPMTU"));
	dev_prop.push_back(Tango::DbDatum("UfxcModel"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	UfxcClass	*ds_class =
		(static_cast<UfxcClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize AutoLoad from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoLoad;
	else {
		//	Try to initialize AutoLoad from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoLoad;
	}
	//	And try to extract AutoLoad value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoLoad;

	//	Try to initialize DetectorConfigFiles from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorConfigFiles;
	else {
		//	Try to initialize DetectorConfigFiles from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorConfigFiles;
	}
	//	And try to extract DetectorConfigFiles value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorConfigFiles;

	//	Try to initialize ConfigIpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  configIpAddress;
	else {
		//	Try to initialize ConfigIpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  configIpAddress;
	}
	//	And try to extract ConfigIpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configIpAddress;

	//	Try to initialize ConfigPort from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  configPort;
	else {
		//	Try to initialize ConfigPort from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  configPort;
	}
	//	And try to extract ConfigPort value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configPort;

	//	Try to initialize SFP1IpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP1IpAddress;
	else {
		//	Try to initialize SFP1IpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP1IpAddress;
	}
	//	And try to extract SFP1IpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP1IpAddress;

	//	Try to initialize SFP1Port from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP1Port;
	else {
		//	Try to initialize SFP1Port from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP1Port;
	}
	//	And try to extract SFP1Port value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP1Port;

	//	Try to initialize SFP2IpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP2IpAddress;
	else {
		//	Try to initialize SFP2IpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP2IpAddress;
	}
	//	And try to extract SFP2IpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP2IpAddress;

	//	Try to initialize SFP2Port from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP2Port;
	else {
		//	Try to initialize SFP2Port from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP2Port;
	}
	//	And try to extract SFP2Port value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP2Port;

	//	Try to initialize SFP3IpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP3IpAddress;
	else {
		//	Try to initialize SFP3IpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP3IpAddress;
	}
	//	And try to extract SFP3IpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP3IpAddress;

	//	Try to initialize SFP3Port from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP3Port;
	else {
		//	Try to initialize SFP3Port from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP3Port;
	}
	//	And try to extract SFP3Port value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP3Port;

	//	Try to initialize Timeout from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  timeout;
	else {
		//	Try to initialize Timeout from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  timeout;
	}
	//	And try to extract Timeout value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  timeout;

	//	Try to initialize MemorizedThresholdLow from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedThresholdLow;
	else {
		//	Try to initialize MemorizedThresholdLow from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedThresholdLow;
	}
	//	And try to extract MemorizedThresholdLow value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedThresholdLow;

	//	Try to initialize MemorizedThresholdHigh from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedThresholdHigh;
	else {
		//	Try to initialize MemorizedThresholdHigh from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedThresholdHigh;
	}
	//	And try to extract MemorizedThresholdHigh value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedThresholdHigh;

	//	Try to initialize MemorizedConfigAlias from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedConfigAlias;
	else {
		//	Try to initialize MemorizedConfigAlias from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedConfigAlias;
	}
	//	And try to extract MemorizedConfigAlias value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedConfigAlias;

	//	Try to initialize MemorizedTriggerAcquisitionFrequency from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedTriggerAcquisitionFrequency;
	else {
		//	Try to initialize MemorizedTriggerAcquisitionFrequency from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedTriggerAcquisitionFrequency;
	}
	//	And try to extract MemorizedTriggerAcquisitionFrequency value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedTriggerAcquisitionFrequency;

	//	Try to initialize MemorizedGeometricalCorrection from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedGeometricalCorrection;
	else {
		//	Try to initialize MemorizedGeometricalCorrection from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedGeometricalCorrection;
	}
	//	And try to extract MemorizedGeometricalCorrection value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedGeometricalCorrection;

	//	Try to initialize MemorizedCountingMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedCountingMode;
	else {
		//	Try to initialize MemorizedCountingMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedCountingMode;
	}
	//	And try to extract MemorizedCountingMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedCountingMode;

	//	Try to initialize SFPMTU from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFPMTU;
	else {
		//	Try to initialize SFPMTU from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFPMTU;
	}
	//	And try to extract SFPMTU value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFPMTU;

	//	Try to initialize UfxcModel from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  ufxcModel;
	else {
		//	Try to initialize UfxcModel from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  ufxcModel;
	}
	//	And try to extract UfxcModel value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  ufxcModel;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	PropertyHelper::create_property_if_empty(this, dev_prop, "False", "AutoLoad");
	PropertyHelper::create_property_if_empty(this, dev_prop, "ALIAS;PATH_AND_FILE_NAME", "DetectorConfigFiles");	
	PropertyHelper::create_property_if_empty(this, dev_prop, "1500", "SFPMTU");
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "ConfigIpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "ConfigPort");
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "SFP1IpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "SFP1Port");
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "SFP2IpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "SFP2Port");
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "SFP3IpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "SFP3Port");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "Timeout");
	PropertyHelper::create_property_if_empty(this, dev_prop, "U2C", "UfxcModel");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedThresholdLow");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedThresholdHigh");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedTriggerAcquisitionFrequency");
	PropertyHelper::create_property_if_empty(this, dev_prop, "False", "MemorizedGeometricalCorrection");
	PropertyHelper::create_property_if_empty(this, dev_prop, "STANDARD", "MemorizedCountingMode");
}
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Ufxc::always_executed_hook()
{
	try
	{
		yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
		m_status_message.str("");
		//- get the singleton control objet used to pilot the lima framework
		m_ct = ControlFactory::instance().get_control("Ufxc");

		//- get interface to specific camera
		m_hw = dynamic_cast<lima::Ufxc::Interface*> (m_ct->hwInterface());

		//- get camera to specific detector
		m_camera = &(m_hw->getCamera());

		//update state
		dev_state();
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		//- throw exception
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}
	catch(...)
	{
		ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
		m_status_message << "Initialization Failed : UNKNOWN" << endl;
		//- throw exception
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}
}
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void Ufxc::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "Ufxc::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	//	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_geometricalCorrection
// 
// description : 	Extract real attribute values for geometricalCorrection acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_geometricalCorrection(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_geometricalCorrection(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        bool enabled;
        m_camera->getGeometricalCorrection(enabled);
		*attr_geometricalCorrection_read = enabled;
		attr.set_value(attr_geometricalCorrection_read);
    }
    catch(Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "Ufxc::read_geometricalCorrection");
    }
    catch(Exception& e)
    {
        manage_lima_exception(e, "Ufxc::read_geometricalCorrection");
    }	
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_geometricalCorrection
// 
// description : 	Write geometricalCorrection attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_geometricalCorrection(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_geometricalCorrection(Tango::WAttribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
		attr.get_write_value(attr_geometricalCorrection_write);
		m_camera->setGeometricalCorrection(attr_geometricalCorrection_write);
		PropertyHelper::set_property(this, "MemorizedGeometricalCorrection", attr_geometricalCorrection_write);
    }
    catch(Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "Ufxc::write_geometricalCorrection");
    }
    catch(Exception& e)
    {
        manage_lima_exception(e, "Ufxc::write_geometricalCorrection");
    }	
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_countingMode
// 
// description : 	Extract real attribute values for countingMode acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_countingMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_countingMode(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        enum lima::Ufxc::Camera::CountingModes counting_mode;
        std::string acq_mode_label;
        std::string error_message;

        m_camera->getCountingMode(counting_mode);

        if(m_camera->convertCountingModeEnum(counting_mode, acq_mode_label, error_message))
        {
            //Set the attribute value
            strcpy(*attr_countingMode_read, acq_mode_label.c_str());
            attr.set_value(attr_countingMode_read);
        }
        else
        {
            Tango::Except::throw_exception("LOGIC_ERROR",
                                           error_message.c_str(),
                                           "Ufxc::read_countingMode");
        }
    }
    catch(Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "Ufxc::read_countingMode");
    }
    catch(Exception& e)
    {
        manage_lima_exception(e, "Ufxc::read_countingMode");
    }	
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_countingMode
// 
// description : 	Write countingMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_countingMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_countingMode(Tango::WAttribute &attr) entering... "<< endl;
    
    bool counting_mode_was_changed = false;
    enum lima::Ufxc::Camera::CountingModes counting_mode;

    {
	    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());

        if(m_is_CountingMode_init)
            return;

        try
        {
	        attr.get_write_value(attr_countingMode_write);

            // we need to convert the acquisition mode string to the enum acquisition mode
            std::string error_message;
            std::string mode_label = std::string(attr_countingMode_write);

            if(!m_camera->convertCountingModeLabel(mode_label, counting_mode, error_message))
            {
                Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                               error_message.c_str(), 
                                               "Controller::write_countingMode()");
            }

            enum lima::Ufxc::Camera::CountingModes old_counting_mode;
            m_camera->getCountingMode(old_counting_mode);

            if(counting_mode != old_counting_mode)
            {
                std::string   old_mode_label;
                unsigned long old_pixel_depth;
                unsigned long new_pixel_depth = m_camera->getCountingModePixelDepth(counting_mode);
                std::ostringstream MsgInfo;

                m_camera->convertCountingModeEnum(old_counting_mode, old_mode_label, error_message);

                // update the memorized value to prepare the init command
                PropertyHelper::set_property(this, "MemorizedCountingMode", mode_label.c_str());
                MsgInfo << "Counting Mode changed from " << old_mode_label << " to " << mode_label << "." << std::endl;

                // get the generic device name
                std::string    device_name ;
                std::string    class_name  = "LimaDetector";
                std::string    server_name = Tango::Util::instance()->get_ds_name();
                Tango::DbDatum db_datum = (Tango::Util::instance()->get_database())->get_device_name(server_name, class_name);
                db_datum >> device_name;

                // trigger change ?
                TrigMode old_trigger_mode;
                TrigMode new_trigger_mode;

			    m_ct->acquisition()->getTriggerMode(old_trigger_mode);

                // the trigger mode change will change the counting mode in the detector
                if(!m_camera->checkTrigModeOfCountingMode(old_trigger_mode, counting_mode))
                {
                    // we are using the default trigger mode to set the counting mode
                    new_trigger_mode = m_camera->getDefaultTrigModeOfCountingMode(counting_mode);
                    
                    std::string old_trigger_label = m_camera->getTrigLabel(old_trigger_mode);
                    std::string new_trigger_label = m_camera->getTrigLabel(new_trigger_mode);

                    Tango::DbData db_data;
                    db_data.push_back(Tango::DbDatum("MemorizedTriggerMode"));
                    (Tango::Util::instance()->get_database())->get_device_property(device_name, db_data);

                    db_data[0] << new_trigger_label.c_str();

                    // forcing the saving of new trigger in tango database
                    (Tango::Util::instance()->get_database())->put_device_property(device_name, db_data);

                    MsgInfo << "Trigger changed from " << old_trigger_label << " to " << new_trigger_label << std::endl;
                }
                else
                {
                    new_trigger_mode = old_trigger_mode;
                    MsgInfo << "Trigger stays to " << new_trigger_mode << std::endl;
                }

                // for the dynamic change of size or/and pixel depth
            #ifdef UFXCCAMERA_USE_DYNAMIC_COUNTING_MODE_CHANGE
                m_camera->setImageType   (m_camera->getImageTypeOfCountingMode(counting_mode));
                m_camera->setCountingMode(counting_mode);

                // the trigger mode change will change the counting mode in the detector
                m_camera->setTrigMode(new_trigger_mode);
                m_ct->acquisition()->setTriggerMode(new_trigger_mode);
                m_camera->updateImageFormat();

                // update the valid ranges for exposure and latency times
                m_hw->getSyncCtrl().updateValidRanges();

                // update the exposure and latency times
                double acq_time;
                m_ct->acquisition()->getAcqExpoTime(acq_time);
                m_camera->getCorrectExposureTime   (acq_time);
                m_ct->acquisition()->setAcqExpoTime(acq_time);

                double lat_time;
                m_ct->acquisition()->getLatencyTime(lat_time);
                m_camera->getCorrectLatTime        (lat_time);
                m_ct->acquisition()->setLatencyTime(lat_time);

                // manage the exposure time property value change
                {
                    Tango::DbData db_data           ;
                    db_data.push_back(Tango::DbDatum("MemorizedExposureTime"));

                    (Tango::Util::instance()->get_database())->get_device_property(device_name, db_data);

                    std::stringstream temp_stream;
                    temp_stream << (acq_time * 1000.0);
                    db_data[0] << temp_stream.str().c_str();

                    (Tango::Util::instance()->get_database())->put_device_property(device_name, db_data);

                    MsgInfo << "Exposure time changed to " << temp_stream.str() << std::endl;
                }

                // manage the latency time property value change
                {
                    Tango::DbData db_data           ;
                    db_data.push_back(Tango::DbDatum("MemorizedLatencyTime"));

                    (Tango::Util::instance()->get_database())->get_device_property(device_name, db_data);

                    std::stringstream temp_stream;
                    temp_stream << (lat_time * 1000.0);
                    db_data[0] << temp_stream.str().c_str();

                    (Tango::Util::instance()->get_database())->put_device_property(device_name, db_data);

                    MsgInfo << "Latency time changed to " << temp_stream.str() << std::endl;
                }

                INFO_STREAM << MsgInfo.str() << endl;

                counting_mode_was_changed = true;

                // call the init interface command of LimaDetector to re-create the image and baseimage attributes
                Tango::DeviceProxy * device_proxy = new Tango::DeviceProxy(device_name);

                if(device_proxy != NULL)
                {
				    // Ping the device
				    device_proxy->ping();

                    INFO_STREAM << "calling the InitInterface method of LimaDetector..." << endl; 

                    Tango::DeviceData dout; 
                    dout = device_proxy->command_inout("InitInterface");
                    delete device_proxy;
                }
            #else
                MsgInfo << "The initialization of the device is necessary." << std::endl;
                MsgInfo << "Please use the init command of your generic device to apply the changes." << std::endl;

                INFO_STREAM << "MsgInfo.str()" << endl;

                Tango::Except::throw_exception("CONFIGURATION_CHANGE", MsgInfo.str().c_str(), "SimulatorCCD::write_fillType", Tango::WARN);
            #endif
            }
        }
        catch(Tango::DevFailed& df)
        {
            manage_devfailed_exception(df, "Ufxc::write_countingMode");
        }
        catch(Exception& e)
        {
            manage_lima_exception(e, "Ufxc::write_countingMode");
        }	
    }

    // not recursive lock problem
    if(counting_mode_was_changed)
    {
        //available only in mode pump & probe (i.e Trigger Ext Multi and Bpp2)
        if(counting_mode == lima::Ufxc::Camera::CountingModes::PumpProbeProbe_32)
        {
            update_triggerAcquisitionFrequency();
        }
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_triggerAcquisitionFrequency
// 
// description : 	Extract real attribute values for triggerAcquisitionFrequency acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_triggerAcquisitionFrequency(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_triggerAcquisitionFrequency(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		*attr_triggerAcquisitionFrequency_read = attr_triggerAcquisitionFrequency_write;
		attr.set_value(attr_triggerAcquisitionFrequency_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_triggerAcquisitionFrequency");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_triggerAcquisitionFrequency
// 
// description : 	Write triggerAcquisitionFrequency attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_triggerAcquisitionFrequency(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_triggerAcquisitionFrequency(Tango::WAttribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_triggerAcquisitionFrequency_write);

        lima::Ufxc::Camera::CountingModes acq_mode;
		m_camera->getCountingMode(acq_mode);

		//available only in mode pump & probe (i.e Trigger Ext Multi and Bpp2)
		if(acq_mode == lima::Ufxc::Camera::CountingModes::PumpProbeProbe_32)
		{
			m_camera->set_pump_probe_trigger_acquisition_frequency(attr_triggerAcquisitionFrequency_write);

            double exposure;
	        m_ct->acquisition()->getAcqExpoTime(exposure);
            m_camera->computePumpProbeNbFrames(exposure);

			m_ct->acquisition()->setAcqNbFrames(1);
			PropertyHelper::set_property(this, "MemorizedTriggerAcquisitionFrequency", attr_triggerAcquisitionFrequency_write);

            // update the valid ranges for exposure and latency times
            m_hw->getSyncCtrl().updateValidRanges();
		}
		else
		{
			//- throw exception
			THROW_DEVFAILED("CONFIGURATION_ERROR",
							"triggerAcquisitionFrequency is used to compute the nbFrames to acquire according to the exposureTime.\n"
							"This functionnality is available only in 'pump & probe mode' (i.e Trigger External Multi & 2 bits).\n",
							"Ufxc::write_triggerAcquisitionFrequency");
		}
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::write_triggerAcquisitionFrequency");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::write_triggerAcquisitionFrequency");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::update_triggerAcquisitionFrequency
// 
//-----------------------------------------------------------------------------
void Ufxc::update_triggerAcquisitionFrequency()
{
    Tango::WAttribute &triggerAcquisitionFrequency = dev_attr->get_w_attr_by_name("triggerAcquisitionFrequency");
    *attr_triggerAcquisitionFrequency_read = attr_triggerAcquisitionFrequency_write = memorizedTriggerAcquisitionFrequency;
    triggerAcquisitionFrequency.set_write_value(*attr_triggerAcquisitionFrequency_read);
    write_triggerAcquisitionFrequency(triggerAcquisitionFrequency);
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_currentAlias
// 
// description : 	Extract real attribute values for currentAlias acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_currentAlias(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_currentAlias(Tango::Attribute &attr) entering... " << endl;
	try
	{
		attr.set_value(attr_currentAlias_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_currentAlias()");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_currentConfigFile
// 
// description : 	Extract real attribute values for currentConfigFile acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_currentConfigFile(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_currentConfigFile(Tango::Attribute &attr) entering... " << endl;
	try
	{
		attr.set_value(attr_currentConfigFile_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_currentConfigFile()");
	}
}


//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdLow1
// 
// description : 	Extract real attribute values for thresholdLow1 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdLow1(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdLow1(Tango::Attribute &attr) entering... " << endl;

	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_Low1(thr);
		*attr_thresholdLow1_read = thr;
		attr.set_value(attr_thresholdLow1_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdLow1");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdLow1");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdHigh1
// 
// description : 	Extract real attribute values for thresholdHigh1 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdHigh1(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdHigh1(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_High1(thr);
		*attr_thresholdHigh1_read = thr;
		attr.set_value(attr_thresholdHigh1_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdHigh1");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdHigh1");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdLow2
// 
// description : 	Extract real attribute values for thresholdLow2 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdLow2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdLow2(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_Low2(thr);
		*attr_thresholdLow2_read = thr;
		attr.set_value(attr_thresholdLow2_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdLow2");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdLow2");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdHigh2
// 
// description : 	Extract real attribute values for thresholdHigh2 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdHigh2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdHigh2(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_High2(thr);
		*attr_thresholdHigh2_read = thr;
		attr.set_value(attr_thresholdHigh2_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdHigh2");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdHigh2");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdLow
// 
// description : 	Extract real attribute values for thresholdLow acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdLow(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdLow(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		*attr_thresholdLow_read = attr_thresholdLow_write;
		attr.set_value(attr_thresholdLow_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdLow");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_thresholdLow
// 
// description : 	Write thresholdLow attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_thresholdLow(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_thresholdLow(Tango::WAttribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_thresholdLow_write);
		m_camera->set_threshold_Low1(attr_thresholdLow_write);
		m_camera->set_threshold_Low2(attr_thresholdLow_write);
		PropertyHelper::set_property(this, "MemorizedThresholdLow", attr_thresholdLow_write);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::write_thresholdLow");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::write_thresholdLow");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdHigh
// 
// description : 	Extract real attribute values for thresholdHigh acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdHigh(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdHigh(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		*attr_thresholdHigh_read = attr_thresholdHigh_write;
		attr.set_value(attr_thresholdHigh_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdHigh");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_thresholdHigh
// 
// description : 	Write thresholdHigh attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_thresholdHigh(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_thresholdHigh(Tango::WAttribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_thresholdHigh_write);
		m_camera->set_threshold_High1(attr_thresholdHigh_write);
		m_camera->set_threshold_High2(attr_thresholdHigh_write);
		PropertyHelper::set_property(this, "MemorizedThresholdHigh", attr_thresholdHigh_write);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::write_thresholdHigh");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::write_thresholdHigh");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_detectorTemperature
// 
// description : 	Extract real attribute values for detectorTemperature acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_detectorTemperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_detectorTemperature(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long temp = 0;
		m_camera->get_detector_temperature(temp);
		*attr_detectorTemperature_read = temp;
		attr.set_value(attr_detectorTemperature_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_detectorTemperature");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_detectorTemperature");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_firmwareVersion
// 
// description : 	Extract real attribute values for firmwareVersion acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_firmwareVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_firmwareVersion(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		std::string version("?.?.?");
		m_camera->get_firmware_version(version);
		strcpy(*attr_firmwareVersion_read, version.c_str());

		attr.set_value(attr_firmwareVersion_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_firmwareVersion");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_firmwareVersion");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_libVersion
// 
// description : 	Extract real attribute values for libVersion acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_libVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_libVersion(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		std::string version("?.?.?");
		m_camera->get_lib_version(version);
		strcpy(*attr_libVersion_read, version.c_str());

		attr.set_value(attr_libVersion_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_libVersion");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_libVersion");
	}
}


//+------------------------------------------------------------------
/**
 *    method:    Ufxc::dev_state
 *
 *    description:    method to execute "State"
 *    This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return    State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState Ufxc::dev_state()
{
	Tango::DevState argout = DeviceImpl::dev_state();
	DEBUG_STREAM << "Ufxc::dev_state(): entering... !" << endl;

	//    Add your own code to control device here
	stringstream DeviceStatus;
	DeviceStatus << "";
	Tango::DevState DeviceState = Tango::STANDBY;
	if(!m_is_device_initialized)
	{
		DeviceState = Tango::FAULT;
		DeviceStatus << m_status_message.str();
	}
	else
	{
		// state & status are retrieved from Factory, Factory is updated by Generic device
		DeviceState = ControlFactory::instance().get_state();
		DeviceStatus << ControlFactory::instance().get_status();
	}

	set_state(DeviceState);
	set_status(DeviceStatus.str());

	argout = DeviceState;

	return argout;
}


//+------------------------------------------------------------------
/**
 *	method:	Ufxc::load_config_file
 *
 *	description:	method to execute "LoadConfigFile"
 *
 * @param	argin	alias of the Detector configuration file
 *
 */
//+------------------------------------------------------------------
void Ufxc::load_config_file(Tango::DevString argin)
{
	DEBUG_STREAM << "Ufxc::load_config_file(): entering... !" << endl;

	//	Add your own code to control device here
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		//  in the property parser "ALIAS;c:\mondossier\monfichier.ini"
		std::string alias = argin;
		std::transform(alias.begin(), alias.end(), alias.begin(), ::toupper);
		//check if alias exist !
		map<std::string, std::string>::const_iterator it = m_map_alias_config_files.find(alias);
		if(it == m_map_alias_config_files.end())
		{
			stringstream ss;
			ss << "Unable to find the alias [" << alias << "]" << endl;
			THROW_DEVFAILED("TANGO_DEVICE_ERROR",
							ss.str().c_str(),
							"Ufxc::load_config_file()");
		}

		//ask the camera to load the file on the board
		//- create an msg to pass it some data (Conf)
		INFO_STREAM << "Load the detector config file : " << m_map_alias_config_files[alias] << std::endl;
		m_my_task->load_config_file(m_camera, m_map_alias_config_files[alias]);

		//update attributes related to config ini file
		strcpy(*attr_currentAlias_read, alias.c_str());
		strcpy(*attr_currentConfigFile_read, (m_map_alias_config_files[alias].c_str()));
		yat4tango::PropertyHelper::set_property(this, "MemorizedConfigAlias", alias);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::load_config_file()");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::load_config_file");
	}
}

//+------------------------------------------------------------------
/**
 *	method:	Ufxc::manage_devfailed_exception
 *
 *	description: method which manages DevFailed exceptions
 */
//+------------------------------------------------------------------
void Ufxc::manage_devfailed_exception(Tango::DevFailed & in_exception, const std::string & in_caller_method_name)
{
    ERROR_STREAM << in_exception << endl;
	
    // rethrow exception
    Tango::Except::re_throw_exception(in_exception,
                                      "TANGO_DEVICE_ERROR",
                                      string(in_exception.errors[0].desc).c_str(),
                                      in_caller_method_name.c_str());
}

//+------------------------------------------------------------------
/**
 *	method:	Ufxc::manage_lima_exception
 *
 *	description: method which manages lima exceptions
 */
//+------------------------------------------------------------------
void Ufxc::manage_lima_exception(lima::Exception & in_exception, const std::string & in_caller_method_name)
{
    ERROR_STREAM << in_exception.getErrMsg() << endl;

    // throw exception
    Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                   in_exception.getErrMsg().c_str(),
                                   in_caller_method_name.c_str());
}


}	//	namespace
